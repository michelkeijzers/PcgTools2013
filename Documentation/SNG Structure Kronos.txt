PRELOAD.sng


Summary

 0090 SNG1
 009E  SDK1
 01B4  RGN1
 05AC  SGS1
        for each song:
 05B8   SDT1 (song 1)
 05C4    SPR1 + 14A8->
 1A6C    BMT1
 3906    TRK1
 3912     MDT1
 391E      MTK1
 392A       MTE1
             VADT1
	 		       ATK1
				     ATE1
					 ATE1 *

1C4FE  SDT1 (song 2)
1C50A   SPR1 + 14A8->
1D9B2   BMT1




Lvl	Index/Offs.	Data_____	Description____________ Value/Structure
	0000 0000	KORG		Korg Header				FileHdKorg
			4	x68			Model					x68 = Kronos	
			6	x01			Type					x02 = Sng
		   18   00 07 83 C0 SNG1 length
		   20   00 00 00 6C Size of header          Starting after
		   24	00 00 00 00	Offset SNG1
		   2B	04			Number of songs			<= $199
		   50   00 00 00 00 Index of first song
		   54	00 01 89 88	Length of first song?
		   58   00 00 00 01 Index of second song
		   5C	00 01 ED 10	Length of second song?
		   60   00 00 00 02 Index of third song
		   64	00 00 8F 88	Length of third song
		   68	00 00 00 03	Index of fourth song
		   6C	00 02 A4 38	Length of fourth song
		   70	00 00 00 00 ???
		   74	00 00 00 01	???
		   78	00 00 00 02 ???
		   7C	00 00 00 03 ???
		   80	00 00 00 04 ???
		   84	00 00 00 05 ???
		   88	00 00 00 06 ???
		   8C	00 00 00 07 ???

 1		   90   SNG1		Chunk					ChunckIdSng				
		   94	00 07 83 24	Length of chuck SNG1
		   98   00 00 04 00	Fixed (?)

 2		   9C	SDK1		Chunk					ChunkIdSongDesc			
           A0   00 00 01 0C
		   A4	00 00 01 00
		   A8	00 00 00 04
		   AC	00 00 00 40
		   B0	00 00 00 00
		   B4	BOM BODOM	Name of song 1
		   ..
		   CC	18 9E 01 00	sizeofsong sizeofmiditracks sizeofmastertracks sizeofaudiotracks sizeofpatterns numofpattern 
		   D0	38 86 01 00 seekoffsetofsongdatachunk sizeofsongdatachunk sizeoftrackschunk?
		   D4	D8 02 00 00
		   D8	78 00 00 00
		   DC	00 00 00 00
		   E0	00 00 00 00
		   E4	00 00 00 00

		   E8	C4 05 00 00
		   EC	3A BF 01 00
		   F0	3A BF 01 00
		   F4	Infected by	Name of song 2
		   ..

 2	      1B4	RGN1		Chunk Region 1 / RGN1
		  1B8	00 00 03 EC	Length of RGN1
		  1BC	00 00 01 00
		  1C0	00 00 00 08
		  1C4	00 00 00 7C
		  1C8	00 00 00 00
		  
		  1CC..	Git.L		Name of sample 1
		  1E4.. SONG001\AT.	Folder name of sample 1
		  238	02 24 9B 00
		  23C	01 00 E0 AE
		  240	00 00 00 00
		  244	00 00 00 00

		  248	Git.R		Name of sample 2
		  ...

 2        5AC   SGS1		Chunk					ChunkIdSongs			
		  5B0	00 07 7E 08	Length of chunk									Length: until end of file
		  5B4	00 00 04 00
		  
 3        5B8   SDT1		Chunk					ChunkIdSongsData		
		  5BC	00 01 BF 3A	Length of chunk									Length: 
		  5C0	00 00 04 00

 4        5C4	SPR1		Chunk					ChunkIdSongControl		
		  5C8	00 00 14 9C	Length of chunk									Length: x149C -> until BMT1
		  5CC	00 00 01 00
		  5D0	00 00 00 01
		  5D4	00 00 14 90	Length?
		  5D8	00 00 00 00
		  5DC	00 00 13 00
		  5E0	E0 2E 00 01
		  5E4	7F 00 02 00
		  5E8	00 00 00 00
		  5EC.. Flute reas	Name MIDI track 1, 
		  60C   18 1F 00 00 Offset (?), byte 26: biti 3 = 0, (play), bit 3 = 1 (mute), bits 1.2.3.4.5.6.7.7
		  610.. Trumpets s	Name MIDI track 2
		  630   00 3C 00 00
		  634..	Organ G6 s	Name track 3
		  654   60 9E 00 00
		  658	Piano G6 s	Name track 4
		  678   B0 D9 00 00
		  67C..	EP mark I	Name track 5
		  69C	C0 EB 00 00	
		  6A0.	EP 200A		Name (?)
		  6A8	A0 FB 05 37
		  6AC	EF FD 05 37
		  6B0	EF FD 05 37
		  6B4	00 00 00 00
		  6B8	00 00 00 00
		  6BC	00 00 00 00
		  6C0	60 F0 00 00
		  6C4..	A.Bass 6	Name (?)
		  6CC	A0 FB 05 37
		  6D0	EF FD 05 37
		  6D4	EF FD 05 37
		  6D8	00 00 00 00
		  6DC	00 00 00 00
		  6E0	00 00 00 00
		  6E4	90 F6 00 00
		  6CC	E.Bass 6	Name ?
		  ...

		  828	38 86 01 00
		  82C	FF FF FF FF
		  830..	Guitar L	Audio track 1 name
		  850	FF FF FF FF
		  854..	Guitar R	Audio track 2 name
		  874	FF FF FF FF
		  ...
		  A28	_DIO TRACK	Audio track 15 name
		  A48	FF FF FF FF
		  A4C	All rights	All rights reserved
		  A64	00 00 00 00
		  ...	Binary data
		  BEC..	PATTERN 00	Patern 0 name
		  C04	01 13 00 00
		  C08	FF FF FF FF
		  C0C..	PATTERN 01	Pattern 1 name
		  C24	01 13 00 00
		  C28	FF FF FF FF
		  ...

 4       1A6C   BMT1		Chunk					ChunkIdTimbreSetSong 	Length: x1E8E -> until TRK1
		 1A70	00 00 1E 8E	Chunk length
		 1A74	00 03 01 00
		 1A78	00 00 00 01
		 1A7C	00 00 1E 82
		 1A80	00 00 00 00
		 1A84..	BOM BODOM	Song name 
		 1A9C	C8 00 00 19
			<binary data>
		 

 3		SDT1

 4		SPR1
 4       2524	BMT1		Chunk  (song 1)
		 2528	00 00 1E 8E	Chunk length
		 252C	00 03 01 00	03 = # Songs (?)
		 2530	00 00 00 01
		 2534	00 00 1E 82	Length
		 2538	00 00 00 00
		 253C	Electro H	Name of song 1
		 <binary data>

		 37FE	Timbre data 1 to 16 (each timbre: FC bytes)

		 A5B8	BMT1		Chunk (song 2)
		 A5BC	1E 8E 00 03	Chunk length
		 A5C0	01 00 00 00
		 A5C4	00 01 00 00
		 A5C8	1E 82 00 00	Length
		 A5CC	Electro		Name of song 2


				
 4		 1E808	BMT1		Chunk (song 3)
 
		 206A2	PTN1

		 206AE	PEV1

		 2084E	PEV1
		 ...

#define ChunkIdPatternsDesc (0x50445831) // ('PDX1')
#define ChunkIdPatternDesc (0x50444b31) // ('PDK1')
#define ChunkIdCueList (0x43554531) // ('CUE1')
#define ChunkIdRegion (0x52474e31) // ('RGN1')
#define ChunkIdSongParam (0x504d5431) // ('PMT1') // !!! unused ?
#define ChunkIdTimbreSetSongExtended (0x424d5432) // ('BMT2')
#define ChunkIdMidiData (0x4d445431) // ('MDT1')
#define ChunkIdMidiTracks (0x4d544b31) // ('MTK1')
#define ChunkIdMasterTracks (0x544d4131) // ('TMA1')
#define ChunkIdMidiEvent (0x4d544531) // ('MTE1')
#define ChunkIdMasterEvent (0x45564d31) // ('EVM1')
#define ChunkIdAudioData (0x41445431) // ('ADT1')
#define ChunkIdAudioTracks (0x41544b31) // ('ATK1')
#define ChunkIdAudioEvent (0x41544531) // ('ATE1')
#define ChunkIdAutomationTracks (0x4b544131) // ('KTA1')
#define ChunkIdAutomationEvent (0x45544131) // ('ETA1')
#define ChunkIdPatterns (0x50544e31) // ('PTN1')
#define ChunkIdPatternEvent (0x50455631) // ('PEV1')


}
:
SongDescriptor (SongN)(N < kMaxNumOfSong)
Patterns Information Chunk;
PatternDescriptor Chunk (Song0) {..........save/load as 
1bank......used to display information of patterns of a song
PatternDescriptor (pattern0 in Song0){........save/load as 1 item, 
structure = "CPatternDescriptor"
patternname[constNumOfNameByte]
sizeofpattern;
}
:
PatternDescriptor (patternN in Song0) (N < kNumOfUserPattern){
patternname[constNumOfNameByte]
sizeofpattern;
}
}
:
PatternDescriptor Chunk (SongN)(N < kMaxNumOfSong)
Cue Lists Chunk.....save/load as 1bank
CueList0........save/load as 1 item
     :
CueListN
Regions Chunk.......save/load as 1bank
Region0........save/load as 1 item
     :
RegionN
Songs Chunk
Song Data Chunk(Song0)
ControlChunk.......structure = "CSongControl"......save/load as 
1bank[sizeof(CSongControl) * 1]
Control Data
TimbreSetChunk.......structure = "CTimbreSetSong" derived from 
"CCombi"......save/load as 1bank[sizeof(CTimbreSetSong) * 1]
TimbreSet Data
TimbreSetExtendedChunk.......structure = 
"CTimbreSetExtendedChunk"......save/load as 
1bank[sizeof(CTimbreSetExtendedChunk) * 1]
TimbreSetExtended Data
Tracks Chunk
MIDI Data Chunk
MIDI Tracks Chunk
MIDI Track Chunk (Track0)......save/load as 
1bank[sizeof(CSeqEvent) * n]
MIDI Track Chunk (Track1)
:
MIDI Track Chunk (TrackN) (N < kNumOfSeqMIDITrack);
Master Tracks Chunk
Master Track Chunk................save/load as 
1bank[sizeof(CMasterEvent) * n]
Audio Data Chunk
Audio Tracks Chunk
Audio Track Chunk (Track0)................save/load as 
1bank[sizeof(CAudioEvent) * n]
Audio Track Chunk (Track1)
:
Audio Track Chunk (TrackN) (N < kNumOfSeqAudioTrack);
Automation(Mixer) Tracks Chunk
Automation Track Chunk (Track0)...............save/load as 
1bank[sizeof(CAutomationEvent) * n]
Automation Track Chunk (Track1)
:
Automation Track Chunk (TrackN) (N < kNumOfSeqAudioTrack);
Patterns Chunk
Pattern Chunk (No0)...............save/load as 
1bank[sizeof(CPatternEvent) * n]
Pattern Chunk (No1)
:
Pattern Chunk (NoN) (N < kNumOfUserPattern);
:
Song Data Chunk(Song1)
ControlChunk.......structure = "CSongControl"......save/load as 
1bank[sizeof(CSongControl) * 1]
:
Song Data Chunk(SongN) (N < kMaxNumOfSong)
------------end of SNG file--------------------------
*/








FILES
=====

Korg Triton


====== From SngViewer, russian developer (see email)

SNG-file Description 
---------------------------------

1. if Length_of_file_Sng<$2B then Exit; {'Error0: too short length of file SNG'}

2. if  (offset:00000020  unsigned 32-bit) +$00000020+$4 = offset:'SNG1'
    then  if (offset:00000018  unsigned 32-bit) not_equal  Length_of_file_Sng
              then Exit; {'Error1: uncorrect length of file SNG'}

3. (offset:0000002B unsigned 8-bit) = Count_of_Songs  - must be less then 199($C7)
                  
4. for iSong=0 to (Count_of_Songs -1) do
    begin  (offset:00000050+iSong*8+3 unsigned 8-bit)=Number_of_Song_in_Sequencer;
                Song_Title='S'+IntegerToString(Number_of_Song_in_Sequencer);
                { List_of_non-empty_Songs : S000 - S001 - S007 - S008  ....  .... S(LastSong) } 
                {SongName - I know that You know it,Michel !!! }                
    end;

5.  if (offset'SNG1'+4: unsigned 32-bit)+offset'SNG1'+$C not_equal Length_of_file_Sng
     then Exit; {'Error1: uncorrect length of section SNG1'}

6. offset'SNG1'+$C = offset'SDK1'
    (offset'SDK1'+4: unsigned 32-bit)+offset'SDK1'+$C = offset'PDX1'
    (offset'PDX1'+4: unsigned 32-bit)+offset'PDX1'+$C = offset'RGN1'
                                                                                                        section RGN1 - List of files.WAV

     (offset'RGN1'+4: unsigned 32-bit)+offset'RGN1'+$C = offset'SGS1'
                                                                                                         section SGS1 include All Tracs
                                                                                                                                              of All Songs
 
     offset'SGS1'+$C=offset'SDT1'         first section SDT1  include All tracs of  first Song

     offsetSDT1Previous := offset'SDT1'

     for iSong=0 to (Count_of_Songs -1) do
     begin  offsetSong := offsetSDT1Previous;
                  begin    { Process with iSong:Song }
                                 offsetMidiTracks := offsetSong+$44;                                 
                                 offsetMixerPage := offsetSong+offsetSngMixer;
                                                                                           { const offsetSngMixerOasys    = $2782 }
                                                                                           { const offsetSngMixerKronos = $278E }
                                                                                           { const SngTrackSizeOasys   = $BA;     }
                                                                                           { const SngTrackSizeKronos = $BC;     }
                                                                                           { const SngMidiTrackSize = 36;               }
                                  For iTrack:=0 to 15 do
                                  begin  
                                              offMidi    := offsetMidiTracks+iTrack*SngMidiTrackSize; 
                                              offMixer := offsetMixerPage +iTrack*SngTrackSize;
                                     { offset=offMidi:   <tMidi>    string  length=SngMidiTrackSize (bytes) }
                                     { offset=offMixer: <tMixer> string  length=SngTrackSize (bytes)         }
                                             TrackName=copy(tMidi,1,24);
                                             Prog:=tMixer[1]; Bank:=tMixer[2];
                                             PlayMute:=tMidi[26] Bit3=0 {play} Bit3=1{Mute} ; {Bits1.2.3.4.5.6.7.8}
                                             Status:=tMixer[3] Bits 1.2.3.4; {0=off; 2=Int; 4=Bth; 6=Ext; 8=Ex2;}
                                             Channel:=tMixer[3] Bits 5.6.7.8;
                                             Pan:=tMixer[15] unsigned 8-bit;{0=Rnd; 1..63=L; 64=C; 65..127=R}
                                             Vol:=tMixer[6];
                                             Transpose:=tMixer[8] signed 8-bit;
                                             KeyboardZone: bottom=tMixer[39]  top=tMixer[38]
                                             velocityZone:     bottom=tMixer[42]  top=tMixer[41] 
                                  end;

                  end;  

                  offsetSDT1Previouce := offsetSong;
                  offsetSDT1Next:=(offset:offsetSDT1Previous+4: unsigned 32-bit)
                                                 + offsetSDT1Previous;
                  offsetSong:=offsetSDT1Next;

       end;   { for iSong=0 to (Count_of_Songs -1) do }
                  
     end

    